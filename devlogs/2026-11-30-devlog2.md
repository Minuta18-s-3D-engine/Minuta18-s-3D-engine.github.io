---
layout: default
title: "30.11.2026. Девлог 2: Система игровых объектов"
parent: Девлоги
nav_order: 2
---

# Девлог #2: Система игровых объектов

Размер этого девлога сравнительно небольшой, т. к. прошла всего неделя. Всё это время я работал над системой **игровых объектов и компонентов**. 

## Entity-Component-System

ECS (Entity-Component-System) - архитектурный паттерн широко используемый в разработке игр, отлично подходящий для имплементации игровых объектов. ECS возводит в абсолют принцип Composition Over Inheritance, а также является примером Data Oriented Design. ECS состоит из трёх типов объектов:
 - **Компоненты** (Component) - какое-то свойство игрового объекта. Представляет собой исключительно контейнер с данными, никакой логики. Вот пример компонента из движка:
    ```cpp
    class Transform : public Component {
    public:
        glm::vec3 position{ 0.0f };
        glm::quat rotation{ 1.0f, 0.0f, 0.0f, 0.0f };
        glm::vec3 scale{ 1.0f };

        std::unique_ptr<Component> clone() override { ... }
    }
    ```
 - **Сущности** (Entity) - в движке это игровые объекты (GameObject). Объединяют компоненты в одну конкретную сущность.
 - **Системы** (System) - здесь содержится вся логика. К примеру `RenderingSystem` обрабатывает игровые объекты, обладающие компонентами `Transform`, `ModelComponent`, `Behavior`.

Однако API движка позволит разработчику не писать в стиле ECS: более традиционные подходы тоже можно будет использовать.

{: .note }
На самом деле движок чуть-чуть сдвинулся в сторону EC (Entity-Component): в силу архитектурных требований у каждого компонента появился обязательный метод .clone(), рассматриваю также введение методов для сериализации и десериализации 

## Юнит-тесты 

Реализация системы игровых объектов была относительно сложной для меня, из-за большого количества методов, взаимодействующих с типовой системой C++, чем я раньше не занимался. Более того, в некоторых классах этой системы буквально десятки методов, всё это проверить в ручную за приемлемое время я бы просто не смог. Поэтому я добавил в проект юнит-тест фреймворк `googletest`. Сейчас `GameObject` - единственная протестированная система в проекте, и видимо будет такой оставаться ещё долго. Создание тестов сейчас - неприоритетная задача.

## Обновление от 7.12.2026

{: .note }
В оригинале это было отдельным девлогом, но я решил их объединить, из-за одной тематики. 

На этой неделе работал над интеграцией системы игровых объектов в существующую кодовую базу. Синтаксис оказался более удобным, чем я ожидал. Однако он довольно многословный. Ситуацию будем исправлять используя встроенные фабрики, вроде такой:

```cpp
void createPointLight(
    glm::vec3 pos, glm::vec3 color, float linear, float quadratic,
    GameObjectManager& objectManager
) {
    std::unique_ptr<GameObject> lightObject = GameObject::createGameObject();
    auto transformComponent = lightObject->getComponent<Transform>();
    transformComponent->position = pos;
    auto behaviorComponent = lightObject->getComponent<Behavior>();
    behaviorComponent->type = BehaviorType::STATIC;
    auto pointLightComponent = std::make_unique<PointLight>();
    pointLightComponent->color = color;
    pointLightComponent->linear = linear;
    pointLightComponent->quadratic = quadratic;
    lightObject->addComponent<PointLight>(pointLightComponent);

    objectManager.addObject(lightComponent);
}
```

В коде RenderingSystem я методом `getObjectsWithComponents()` получал массив нужных мне объектов. Быстро выяснилось, что копировать 10K+ указателей каждый кадр - сомнительная идея. Я добавил в эту систему кэш, что исправило ситуацию.