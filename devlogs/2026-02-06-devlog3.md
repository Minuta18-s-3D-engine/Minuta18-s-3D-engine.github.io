---
layout: default_with_comments
title: "06.02.2026. Девлог 3: Загрузка моделей, система событий"
parent: Девлоги
comments: true
nav_order: 3
---

![Известная модель sponza, загруженная в движок](/assets/images/devlogs/about/1.png)

<span class="text-grey-dk-000">Известная модель Sponza, загруженная в движок</span>

# Девлог #3: Система моделей, система событий

Несмотря на то что с последнего девлога прошло уже почти 2 месяца, изменений было сделано мало. Работа была заторможена сессией и новогодними праздниками. 

## Модели

Система моделей была написана довольно быстро: тогда я готовился к конференции, и мне было крайне важно успеть доделать эту фичу. На мой взгляд, это к тому времени сыграло самую важную роль в визуальном образе проекта.

Система, которую я написал, имеет довольно классическую архитектуру. Структура **вершины**, одна из самых фундаментальных частей модели, выглядит так:

```cpp
struct Vertex {
    glm::vec3 pos, normal;
    glm::vec2 texCords;
    glm::vec3 tangent, bitangent;
};
```

Она включает в себя позицию, нормаль, UV-координаты, тангент и битангент. 

{: .note }
Да, несмотря на то, что данные о карте нормалей (тангент и битангент), в настоящее время они ещё не используются непосредственно в рендеринге.

Вершины образуют вместе сетку (далее в тексте "меш"), которая хранится в классе `Mesh`. Кроме хранения, меш занимается взаимодействием с OpenGL: генерирует `VAO`, `VBO` и `EBO`, а также передаёт меш в шейдер, вместе с текстурами и материалами. Впрочем, последняя функция кажется ошибкой, - это нарушение Single Responsibility Principle. В будущем эта логика будет перенесена в систему рендеринга. 

Однако, часто модели содержат более одного меша. Для хранения и организации мешей был создан класс `Model`. Кроме этого ничего интересного он в себе не содержит, поэтому на нём мы подробно останавливаться не будем.

### ModelLoader

Самая сложная задача, которой занимается система - загрузка моделей из файлов. Вся логика была сокрыта в классе `ModelLoader`, который с клиентской точки зрения содержит всего один метод:

```cpp
class ModelLoader {
public:
    std::unique_ptr<Model> loadModel(const std::string& filename);
};
```

Внутри же класс устроен значительно сложнее. Для чтения большинства популярных типов файлов, в которых хранятся модели, я использовал библиотеку *Assimp*. При иных обстоятельствах я бы попробовал разработать более-менее самописное решение, однако на момент разработки системы моделей я стоял перед жёстким дедлайном, из-за чего решил прибегнуть к готовому решению. Впрочем, в своих ожиданиях относительно простоты использования Assimp я заблуждался: написание загрузчика моделей, вместе со всем необходимым заняло у меня около недели.

Итак, давайте всё-таки перейдём к рассмотрению подробностей реализации ModelLoader. Все форматы файлов моделей хранят данные по-разному, и даже имеют разные возможности. Assimp предоставляет для них всех удобный общий интерфейс, что делает его невероятно удобным, если нужно поддерживать сразу несколько форматов, что я и делаю. 

![Схема структур Assimp](/assets/images/devlogs/3/1.png)

<span class="text-grey-dk-000">Схема структур Assimp</span>

Структура Assimp `aiScene`, которая является загруженной моделью, содержит указатель на дерево `aiNode`. Каждая нода содержит некоторое количество мешей. Обход такого дерева я выполнил рекурсивно, что выглядит лаконично, но потенциально вызовет проблемы в случае загрузки очень больших моделей: 

```cpp
void ModelLoader::processNode(aiNode* node, const aiScene* scene) {
    for (uint i = 0; i < node->mNumMeshes; ++i) {
        // Обработка меша
    }

    for (uint i = 0; i < node->mNumChildren; ++i) {
        processNode(node->mChildren[i], scene);
    }
}
```

Впрочем, обычно глубина сцены не превышает разумных пределов. Переписывание этой части кода с использованием стека - явно не приоритетная задача, но в будущем она точно будет реализована. 

### Загрузка текстур моделей

Написав обход дерева Assimp, я начал писать обработку мешей, после чего столкнулся с необходимостью загружать текстуры, которые они использовали. Тогда в движке уже существовала полностью рабочая загрузка PNG-текстур, из-за чего я подумал, что это не будет сложно (я ошибся).

{: .note }
Я не нашёл единой терминологии для обозначения типов текстур, так что буду использовать уже сложившуюся в проекте. 

Текстуры в моделях встречаются двух типов: `external` (рус.: внешние) и `embedded` (рус.: встроенные). Разница между ними небольшая: встроенные загружаются напрямую из бинарного файла модели (например, `.fbx` или `.glb`), а внешние - из других файлов (например, `.jpg` в той же папке). API для работы с ними в Assimp тоже очень похожее.

А вот форматы текстур заставляют загружать их совершенно по-разному. До этого в движке был только загрузчик PNG-текстур. Однако форматы с сжатием, такие как JPEG, встречаются гораздо чаще.

Примерно с этого момента у меня появились мысли о внедрении библиотек, занимающихся загрузкой текстур (вроде `stb_image.h`) - так поддерживать множество форматов было бы гораздо проще. Но я хотел что-то "более самописное", из-за чего я выбрал `libjpeg-turbo` (аналогично `libpng`, который я использовал для загрузки PNG). `libjpeg-turbo` позволяет добиться максимальной производительности и контроля над процессом, хотя я, конечно, пожалел об этом во время отладки.

### Краткие итоги по моделям

Главное достижение этой системы вы видели ещё в скриншоте в начале девлога. На нём изображена загруженная в движок известная модель Sponza. В ней около 262 тыс. полигонов, также я расставил примерно 50 динамических источников света. При всём этом движок стабильно работает в 60+ фпс. По меркам современных движков результаты не самые впечатляющие, но для моего движка это значительный прогресс. 

## Система событий

Система событий - одна из важнейших систем почти любого движка. Главная суть этой системы - разделить отправителя и получателя какого-то **события**. Иначе говоря, отправитель может создать событие, ничего не зная о получателе, т. е. понижая связность. К примеру, до реализации этой системы, мне приходилось писать подобные костыли: 

```cpp
// src/engine/graphics/RenderingSystem.cpp
RenderingSystem::RenderingSystem(
    // ...
) {
    // ...
    Window::addframebufferCallback([&] (GLFWwindow* win, int width, int height) {
        gBuffer->resize(width, height);
    });
}
```

<span class="text-grey-dk-000">Да, тогда ещё Window был статическим классом, это уже исправлено, см. раздел "рефактор системы `window`"</span>

```cpp
// src/engine/window/Window.cpp
void Window::addframebufferCallback(FramebufferCallback callback) {
    Window::framebufferSizeCallbacks.push_back(callback);
}

// ...

void framebufferSizeCallback(GLFWwindow* win, int width, int height) {
    // ...
    for (auto& callback : Window::framebufferSizeCallbacks) {
        callback(win, width, height);
    }
}
```

Теперь же я могу обратиться к системе событий, которая сделает всю работу:

```cpp
// src/engine/graphics/RenderingSystem.cpp
RenderingSystem::RenderingSystem(
    // ...
) {
    // ...
    eventManager.subscribe<WindowResizeEvent>(
        this, &RenderingSystem::onWindowResize);
}
```

```cpp
// src/engine/window/Window.cpp
void Window::framebufferSizeCallback(
    GLFWwindow* _window, int _width, int _height
) {
    // ...
    eventManager.triggerEvent(WindowResizeEvent(_width, _height));
}
```

### Подробности реализации

Основа `EventManager` - это очередь событий, которая реализована в виде вектора `std::unqiue_ptr<Event>`, и хэш-таблица подписчиков. 

#### std::type_index

В качестве типа ключа этой хэш-таблицы я использовал `std::type_index` - удивительно удобная штука, о которой я пока довольно редко вижу в проектах людей, так что решил уделить ей небольшой отрывок в этом девлоге. Смысл `std::type_index` - предоставить для каждого класса, объявленного в программе, уникальный идентификатор. Т. е. гарантируется:

```cpp
std::type_index ti1 = typeid(A);
std::type_index ti2 = typeid(A);
std::type_index ti3 = typeid(B);
 
assert(ti1 == ti2); 
assert(ti1 != ti3); 
```

#### Класс Event

`Event` стал базовым классом для событий. Единственный функционал, который он реализует сам по себе - возможность пометить событие как обработанное, после чего `EventManager` не будет вызывать других подписанных.

{: .note }
Вообще, пока я это писал, я решил, что это довольно странная идея, ведь на данный момент нет способа задать в каком порядке будут обрабатываться события. Скорее всего в будущем этот флаг останется, но только для разработчиков, `EventManager` на него реагировать не будет.

Как я уже говорил выше, `Event` - базовый класс, т. е. для создания событий он переопределяется. На практике это выглядит так:

```cpp
class WindowResizeEvent : public Event {
public:
    uint32_t newWidth, newHeight;

    WindowResizeEvent(uint32_t _newWidth, uint32_t _newHeight) 
        : newWidth(_newWidth), newHeight(_newHeight) {}
};
```

{: .note}
Каждый раз, когда я пишу системы сильно зависимые от типовой системы C++, которые могут быть полезны для внутренне-игровой логики, встаёт пока что нерешённый вопрос о будущем интеграции этой системы в скриптинг. Возможно мне придётся добавить событие вроде `ScriptingEvent`, которое будет содержать поле типа условного `LuaTable*` или даже `void*` (пока неизвестно, т. к. с языком скриптинга я ещё не определился). В этом случае возникнут проблемы с вышеупомянутым оператором std::typeid, ведь мне придётся обзавестись динамической генерацией идентификатора для `ScriptingEvent`. Ещё один вариант - написать отдельную систему для событий скриптов, возможно даже наследовав её от `EventManager`, но это приведёт к значительному дублированию кода.

#### Класс EventHandler

Чтобы в одном векторе хранить коллбэки разных типов, пришлось сделать хитрый трюк (также известный как Type Erasure): я написал отдельный класс-обёртку для коллбэков - `EventHandler<DerivedEvent>` (где `DerivedEvent` = `concept DerivedEvent = std::is_base_of<Event, T>::value;`). Однако `EventHandler<DerivedEvent>` - всё ещё не один тип, ведь `DerivedEvent` может быть разным. Чтобы обойти, это я написал интерфейс `EventHandlerInterface`, который не является шаблонным.

#### EventConnection

Результат работы метода `eventManager.subscribe()` - `EventConnection`. Этот класс хранит некоторые метаданные, которых достаточно, чтобы, используя его, восстановить подписчика. Этот механизм необходим, чтобы класс мог *отписаться*. Это необходимо, чтобы в случае удаления экземпляра класса в `EventManager` не оставался битый указатель на его метод.

### Краткие итоги по системе событий

Получившаяся система событий, по моему мнению, вышла одной из самых чистых в движке, при этом очень удобной. Её синтаксисом я доволен больше всего - он в чём-то напоминает синтаксис ранее изученного мною Qt, но мне нравится в разы сильнее, банально потому что более лаконичный. Впрочем, вместо моих слов гораздо лучшей демонстрацией станет её практическое применение, которое будет затронуто в следующем разделе.

## Рефактор системы window

Оконная система - одна из самых древних систем движка, при этом она была одной из худших. Когда я её писал, я ещё не определился со стилем написания. В результате, вместо ООП+DI подхода, который в основном сейчас используется в движке, оконная система была оформлена в виде набора статических классов. После того, как я написал систему событий, я решил исправить вышеупомянутые костыли, что привело меня к полноценному рефакторингу.  

### Новая архитектура системы

В оконной системе существует всего два класса. Первый из них - класс окна (`Window`). Его было достаточно легко переписать, т. к. почти никакой сложной логики он не содержал. Большая часть его методов - геттеры и сеттеры либо внутренних параметров, либо параметров OpenGL. Сложнее дела обстояли с `InputController` (кстати тогда он имел странноватое название `UserInput`). Дело в том, что из-за особенностей GLFW указатель `GLFWwindow*` используется как для управления вводом, так и для получения информации о вводе. Это создаёт проблемы:
 - `InputController` становится "расширением" класса `Window`, ведь `InputController` нужен широкий доступ к приватным переменным `Window` и наоборот. Объединить их в один класс я также не хотел, ведь логической связи между ними нет.
 - Вышеуказанное обстоятельство создаёт крайне неприятную круговую зависимость.
Для решения этих проблем был найден компромисс: `InputController` становится friend-классом `Window`. Чтобы избежать неудобной инициализации я также решил, что `Window` будет иметь свой экземпляр класса `InputController`, который будет инициализирован автоматически при инициализации `Window`. Получается он через метод `InputController& getInputController()`.

### Использование системы событий

Система событий ещё только начинает интеграцию в движок, из-за чего новая оконная система стала первым и пока что единственным источником событий. Я добавил событие `WindowResizeEvent`, которое вызывается при изменении размеров окна, и используется для корректировки размеров экранных буферов. Я также хотел добавить события, вызываемые при нажатии и отжатии клавиши, но не успел. Эти события появятся в движке в ближайшее время.

## Заключение 

Подводя итоги, все фундаментальные системы проекта были завершены. Стиль проекта чётко выработан, вся кодовая база была на него переведена. От разрозненных классов с жёсткими зависимостями проект перешёл к гибкой событийно-ориентированной архитектуре, позволяя мне сконцентрироваться на расширении функционала, как ещё в моих первых девлогах. Впереди ещё много работы, например, скоро я займусь доработкой освещения, также в ближайших системах уплотнение интеграции ECS, но скелет проекта уже готов. Спасибо, что дочитали до конца этот девлог! Буду очень рад услышать ваши мнения и критику в комментариях, это важно чтобы повысить качество моих заметок. 
