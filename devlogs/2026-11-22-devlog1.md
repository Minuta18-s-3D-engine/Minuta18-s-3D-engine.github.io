---
layout: default
title: "11.22.2026. Девлог 1: Clustered Deferred Rendering"
parent: Девлоги
nav_order: 1
---

![](/assets/images/devlogs/1/1.png)

<span class="text-grey-dk-000">6000 источников света и ~100000 полигонов</span>

# Девлог #1: Clustered Deferred Rendering

Первый девлог! Изменений за последние 2 месяца произошло немного. Если не учитывать минорные архитектурные улучшения, то главным нововведением стало возможность размещения нескольких источников света на сцене. Я провёл значительную работу над оптимизацией, чтобы получить хорошую производительность. Само освещение также претерпело изменения, но незначительные.

## Forward Rendering

Моей первой попыткой обновить освещение был простой **Forward Rendering**. Forward Rendering - вероятно самый простой метод освещения. Каждый объект рендерится отдельным проходом. Проще говоря, подобный код:

{% highlight glsl %}
out vec4 FragColor;
  
void main() {
  vec3 output = vec3(0.0);
  output += calcAmbientLight();
  output += calcDiffuseLight();
  output += calcSpecularLight();
  FragColor = vec4(output, 1.0);
}
{% endhighlight %}

Становится таким:

{% highlight glsl %}
out vec4 FragColor;
  
void main() {
  vec3 output = vec3(0.0);
  output += calcAmbientLight();
  for (lights) {
    output += calcDiffuseLight(light);
    output += calcSpecularLight(light);
  }
  FragColor = vec4(output, 1.0);
}
{% endhighlight %}

Forward Rendering даёт отличные результаты на простых сценах, однако для более сложных совершенно неприменим. Сложность этого алгоритма - `O(N*M)`, где N - количество вызовов отрисовки, а M - количество источников света. Таким образом, если у вас, например, 1000 вызовов отрисовки и 1000 источников света, алгоритм будет уже выдавать сильные просадки фпс. 

У алгоритма есть ещё одна проблема: как оказалось, видеокарта очень медленно справляется с циклами. Цикл, обрабатывающий 1000 источников света, уже создаёт значительное понижение производительности, даже если он исполняется лишь для одного объекта.

## Deferred Rendering

Чтобы исправить вышеописанные проблемы, я обратился к алгоритму **Deferred Rendering** (на русском: *отложенное освещение*). Если один объект относительно камеры находится за другим объектом, Forward Rendering его полностью отрендерит, хотя некоторые пиксели невидны. Deferred Rendering решает эту проблему следующим образом:  
1. *Первый этап.* Вместо того чтобы сразу выводить картинку на экран, поместим её в специальный **экранный буфер** (в контексте Deferred Rendering есть более специфичный термин - G-buffer). Причём буферов будет несколько: для world-space позиции, для нормалей и для текстуры. 
2. *Второй этап.* Теперь данных в буфере достаточно, чтобы для пикселя вычислить его освещение, после чего вывести на экран. Таким образом для каждого пикселя освещение просчитывается не более одного раза. 

![Иллюстрация к Deferred Rendering](/assets/images/devlogs/1/2.png)

<span class="text-grey-dk-000">Иллюстрация к Deferred Rendering. Источник изображения - learnopengl.com</span>

Deferred Rendering гораздо менее зависим от количества объектов, но не менее зависим света. Моя реализация выдавала низкую производительность уже на 1000 источников света, из-за чего я решил реализовать следующую оптимизацию.

## Clustered Rendering

![Иллюстрация к Clustered Rendering](/assets/images/devlogs/1/3.png)

<span class="text-grey-dk-000">Иллюстрация к Clustered Rendering. Источник изображения - https://github.com/DaveH355/clustered-shading</span>

**Clustered Rendering** - самый сложный в реализации метод освещения, но также самый эффективный. Clustered Rendering предлагает разбить пространство камеры на некоторое количество **кластеров** - фигур, напоминающих **view frustum** - усечённую пирамиду (см. иллюстрацию). Для каждого кластера необходимо найти какие источники света с ним пересекаются. Потом, на стадии просчёта освещения мы проводим расчеты освещения пикселя только с теми источниками освещения, которые находятся в одном с ним кластере.

На практике реализация *Light Culling* (этап определения источников света кластеров) значительно проще, чем может показаться. Во-первых источники освещения будем представлять в виде сфер, т. к. в настоящее время в проекте используются только точечные источники освещения. Во-вторых вместо усечённых пирамид можно использовать описанные AABB. 

Clustered Rendering получился отличной оптимизацией - фактически мы просчитываем только те источники света, которые влияют на пиксель. Более того, максимальное количество источников света в кластере легко ограничить. В настоящее время лимит - 256 источников света на кластер.

Во время реализации этого алгоритма дольше всего я разбирался с SSBO. SSBO - специальный массив, хранящийся на видеокарте, что обеспечивает высокую скорость доступа к данным в нём хранящимся. С SSBO существуют множество нюансов работы на процессоре и некоторые сложности в дебаге, т. к. работа с данными происходит на шейдере. Один раз я дебажил шейдер больше недели, пытаясь понять где конкретно я забыл инициализировать SSBO, и правильно ли передаются данные. Впрочем самая непонятная ситуация возникла, когда я переписал себе этот отрывок из туториала DaveH355:

```glsl
struct Cluster {
    vec4 minPoint;
    vec4 maxPoint;
    uint count;
    uint lightIndices[100];
};
```

Этот код вызывал сильное падение производительности движка. На сценах, без освещения работавших в 70-80 фпс, производительность падала до 30-40 фпс. Я провёл бесчисленное количество часов, пытаясь это исправить и перепроверяя код десятки раз. В результате помогло разделение это куска на два SSBO: один для данных кластера, как и сейчас, но lightIndices теперь стал отдельным SSBO. 

## Clustered Deferred Rendering 

После реализации Clustered Rendering выяснилось, что его можно крайне легко комбинировать с Deferred Rendering. Пайплайн стал выглядеть так:
1. 1 проход Deferred (заполнение буфера).
2. Постройка кластеров. 
3. Light Culling.
4. 2 проход Deferred (просчёт света). 

## Внедрение BVH

![Принцип работы BVH](/assets/images/devlogs/1/4.png)

<span class="text-grey-dk-000">Принцип работы BVH. Первоисточник изображения неизвестен.</span>

Оптимизации на этом не кончились: Light culling требует значительных вычислений: для каждого кластера мы проходим по всем источникам освещения, даже если они расположены в сотнях метров от кластера. Тут я подумал использовать **BVH** (Bounding Volume Hierarchy). BVH - бинарное дерево где каждая вершина, хранит AABB, при этом соблюдая следующие критерии:
1. AABB - Минимально необходимый чтобы в него поместились все AABB в этой вершине и во всех дочерних вершинах.
2. Суммарный объём AABB минимален. 

Использование BVH позволяет сильно сократить количество обходимых объектов: если AABB вершины не пересекается с кластером, то и не пересекаются все дочерние вершины.

## Модель Блина-Фонга

![Сравнение модели Фонга и модели Блинна-Фонга](/assets/images/devlogs/1/5.png)

<span class="text-grey-dk-000">Сравнение модели Фонга и модели Блинна-Фонга. Источник изображения - learnopengl.com</span>

Последнее реализованное изменение - замена освещения по Фонгу на модель Блинна-Фонга. Это позволяет создать ещё более реалистичное освещение при минимальных издержках.

## Заключение

Это был мой первый девлог, поэтому мне было бы очень важно услышать ваше мнение в комментариях. Пока не знаю, когда напишу следующий, в идеале я хотел бы вписаться в еженедельный цикл. Посмотрим получится ли.
