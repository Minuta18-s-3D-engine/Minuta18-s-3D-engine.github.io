---
layout: default_with_comments
title: "04.02.2026. Девлог 3: Загрузка моделей, система событий"
parent: Девлоги
comments: true
nav_order: 3
nav_exclude: true
---

![Известная модель sponza, загруженная в движок](/assets/images/devlogs/about/1.png)

<span class="text-grey-dk-000">Известная модель Sponza, загруженная в движок</span>

# Девлог #3: Система моделей, система событий

Несмотря на то что с последнего девлога прошло уже почти 2 месяца, изменений было сделано мало. Работа была заторможена сессией и новогодними праздниками. 

## Модели

Система моделей была написана довольно быстро: тогда я готовился к конференции, и мне было крайне важно успеть доделать эту фичу. На мой взгляд, это к тому времени сыграло самую важную роль в визуальном образе проекта.

Система, которую я написал, имеет довольно классическую архитектуру. Структура **вершины**, одна из самых фундаментальных частей модели, выглядит так:

```cpp
struct Vertex {
    glm::vec3 pos, normal;
    glm::vec2 texCords;
    glm::vec3 tangent, bitangent;
};
```

Она включает в себя позицию, нормаль, UV-координаты, тангент и битангент. 

{: .note }
Да, несмотря на то, что данные о карте нормалей (тангент и битангент), в настоящее время они ещё не используются в непосредственно рендеринге.

Вершины образуют вместе сетку (далее в тексте "меш"), которая хранится в классе `Mesh`. Кроме хранения, меш занимается взаимодействием с OpenGL: генерирует `VAO`, `VBO` и `EBO`, а также передаёт меш в шейдер, вместе с текстурами и материалами. Впрочем, последняя функция кажется ошибкой, - это нарушение Single Responsibility Principle. В будущем эта логика будет перенесена в систему рендеринга. 

Однако, часто модели содержат более одного меша. Для хранения и организации мешей был создан класс `Model`. Кроме этого ничего интересного он в себе не содержит, поэтому на нём мы подробно останавливаться не будем.

### ModelLoader

Самая сложная задача, которой занимается система - загрузка моделей из файлов. Вся логика была сокрыта в классе `ModelLoader`, который с клиентской точки зрения содержит всего один метод:

```cpp
class ModelLoader {
public:
    std::unique_ptr<Model> loadModel(const std::string& filename);
};
```

Внутри же класс устроен значительно сложнее. Для чтения большинства популярных типов файлов, в которых хранятся модели, я использовал библиотеку *Assimp*. При иных обстоятельствах я бы попробовал разработать более-менее самописное решение, однако на момент разработки системы моделей я стоял перед жёстким дедлайном, из-за чего решил прибегнуть к готовому решению. Впрочем, в своих ожиданиях относительно простоты использования Assimp я заблуждался: написание загрузчика моделей, вместе со всем необходимым заняло у меня около недели.

Итак, давайте всё-таки перейдём к рассмотрению подробностей реализации ModelLoader. Все форматы файлов моделей хранят данные по-разному, и даже имеют разные возможности. Assimp предоставляет для них всех удобный общий интерфейс, что делает его невероятно удобным, если нужно поддерживать сразу несколько форматов, что я и делаю. 

![Схема структур Assimp](/assets/images/devlogs/3/1.png)

<span class="text-grey-dk-000">Схема структур Assimp</span>

Структура Assimp `aiScene`, которая является загруженной моделью, содержит указатель на дерево `aiNode`. Каждая нода содержит некоторое количество мешей. Обход такого дерева я выполнил рекурсивно, что выглядит лаконично, но потенциально вызовет проблемы в случае загрузки очень больших моделей: 

```cpp
void ModelLoader::processNode(aiNode* node, const aiScene* scene) {
    for (uint i = 0; i < node->mNumMeshes; ++i) {
        // Обработка меша
    }

    for (uint i = 0; i < node->mNumChildren; ++i) {
        processNode(node->mChildren[i], scene);
    }
}
```

Впрочем, обычно глубина сцены не превышает разумных пределов. Переписывание этой части кода с использованием стек - явно не приоритетная задача, но в будущем она точно будет реализована. 

### Загрузка текстур моделей

Написав обход дерева Assimp, я начал писать обработку мешей, после чего столкнулся с необходимостью загружать текстуры, которые они использовали. Тогда в движке уже существовала полностью рабочая загрузка PNG-текстур, из-за чего я подумал, что это не будет сложно (я ошибся).

{: .note }
Я не нашёл единой терминологии для обозначения типов текстур, так что буду использовать уже сложившуюся в проекте. 

Текстуры в моделях встречаются двух типов: `external` (рус.: внешние) и `embedded` (рус.: встроенные). Разница между ними небольшая: встроенные загружаются напрямую из бинарного файла модели (например, `.fbx` или `.glb`), а внешние - из других файлов (например, `.jpg` в той же папке). API для работы с ними в Assimp тоже очень похожее.

А вот форматы текстур заставляют загружать их совершенно по-разному. До этого в движке был только загрузчик PNG текстур. Однако форматы с сжатием, такие как JPEG, встречаются гораздо чаще.

Примерно с этого момента у меня появились мысли о внедрении библиотек, занимающихся загрузкой текстур (вроде `stb_image.h`) - так поддерживать множество форматов было бы гораздо проще. Но я хотел что-то "более самописное", из-за чего я выбрал `libjpeg-turbo` (аналогично `libpng`, который я использовал для загрузки PNG). `libjpeg-turbo` позволяет добиться максимальной производительности и контроля над процессом, хотя я, конечно, пожалел об этом во время отладки.

### Краткие итоги по моделям

Главное достижение этой системы вы видели ещё в скриншоте в начале девлога. На нём изображена загруженная в движок известная модель Sponza. В ней около 262 тыс. полигонов, также я расставил примерно 50 динамических источников света. При всём этом движок стабильно работает в 60+ фпс. По меркам современных движков результаты не самые впечатляющие, но для моего движка это значительный прогресс. 
